<!DOCTYPE html>
<html>
<head>
    <title>Sliding Puzzle Game</title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.4/brython.min.js"></script>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.4/brython_stdlib.js"></script>
    <style>
        .puzzle-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr); /* Adjust based on puzzle size */
            grid-gap: 5px;
            max-width: 400px;
            margin: auto;
        }
        .puzzle-tile {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100px;
            background-color: skyblue;
            border: 1px solid #333;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.3s ease; 
        }
        .puzzle-tile.empty {
            background-color: transparent;
            border: none;
            cursor: default;
        }
    </style>
</head>
<body onload="brython()">

<div id="puzzle-container" class="puzzle-grid">
    <!-- Puzzle tiles will be generated here -->
</div>

<script type="text/python">
    from browser import document
    import random

    # State to keep track of the tiles
    puzzle_size = 4
    puzzle_state = [[] for _ in range(puzzle_size)]

    def find_possible_movements(puzzle):
        # Find the position of the empty tile (0)
        for i, row in enumerate(puzzle):
            for j, value in enumerate(row):
                if value == 0:
                    empty_tile_position = (i, j)
                    break

        movements = []
        x, y = empty_tile_position
        puzzle_size = len(puzzle)
    
        # Possible moves: above, below, left, right
        possible_moves = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]
    
        for move_x, move_y in possible_moves:
            if 0 <= move_x < puzzle_size and 0 <= move_y < puzzle_size:
                movements.append(puzzle[move_x][move_y])

        return movements

    def create_tile(number, row, col):
        tile = document.createElement('div')
        tile.className = 'puzzle-tile'
        if not number:
            tile.classList.add('empty')
            tile.text = ''
        else:
            tile.text = str(number)
        tile.bind('click', on_tile_click)
        tile.id = f'tile-{row}-{col}'
        puzzle_state[row].append(number)
        return tile

    def on_tile_click(event):
        tile_number = event.target.text
        movements = find_possible_movements(puzzle_state)
        if tile_number and int(tile_number) in movements:
            move_tile(event.target)

    def move_tile(clicked_tile):
        row, col = map(int, clicked_tile.id.split('-')[1:])
        empty_row, empty_col = find_empty_tile_position(puzzle_state)

        # Swap the clicked tile with the empty space
        puzzle_state[row][col], puzzle_state[empty_row][empty_col] = \
        puzzle_state[empty_row][empty_col], puzzle_state[row][col]

        # Update the UI
        update_puzzle_ui()

    def find_empty_tile_position(puzzle):
        for i, row in enumerate(puzzle):
            for j, value in enumerate(row):
                if value == 0:
                    return (i, j)
        return None

    def update_puzzle_ui():
        for row in range(puzzle_size):
            for col in range(puzzle_size):
                tile_number = puzzle_state[row][col]
                tile = document[f'tile-{row}-{col}']
                tile.text = str(tile_number) if tile_number != 0 else ''
                if tile_number == 0:
                    tile.classList.add('empty')
                else:
                    tile.classList.remove('empty')

    def generate_puzzle():
        puzzle_container = document['puzzle-container']
        numbers = list(range(1, puzzle_size**2))
        random.shuffle(numbers)
        numbers += [0]
    
        for index, number in enumerate(numbers):
            row = index // puzzle_size  # Calculate row
            col = index % puzzle_size  # Calculate column
            tile = create_tile(number, row, col)
            puzzle_container <= tile

    generate_puzzle()
    print(puzzle_state)
    movements = find_possible_movements(puzzle_state)
    print(movements)
</script>

</body>
</html>
